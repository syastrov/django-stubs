from typing import Any, Optional, TypeVar, Union, Literal, overload
from decimal import Decimal
import datetime

class DjangoUnicodeDecodeError(UnicodeDecodeError):
    obj: bytes = ...
    def __init__(self, obj: bytes, *args: Any) -> None: ...

python_2_unicode_compatible: Any

def smart_text(s: Any, encoding: str = ..., strings_only: bool = ..., errors: str = ...) -> str: ...
def is_protected_type(obj: Any) -> bool: ...

_ProtectedType = TypeVar(
    "_ProtectedType", Union[None, int, float, Decimal, datetime.datetime, datetime.date, datetime.time]
)
@overload
def force_text(s: str, encoding: str = ..., strings_only: bool = ..., errors: str = ...) -> str: ...
@overload
def force_text(
    s: _ProtectedType, encoding: str = ..., strings_only: Literal[True] = ..., errors: str = ...,
) -> _ProtectedType: ...
@overload
def force_text(s: Any, encoding: str = ..., strings_only: bool = ..., errors: str = ...) -> str: ...
def smart_bytes(s: Any, encoding: str = ..., strings_only: bool = ..., errors: str = ...) -> bytes: ...
def force_bytes(s: Any, encoding: str = ..., strings_only: bool = ..., errors: str = ...) -> bytes: ...

smart_str = smart_text
force_str = force_text

def iri_to_uri(iri: Optional[str]) -> Optional[str]: ...
def uri_to_iri(uri: Optional[str]) -> Optional[str]: ...
def escape_uri_path(path: str) -> str: ...
def repercent_broken_unicode(path: bytes) -> bytes: ...
def filepath_to_uri(path: Optional[str]) -> Optional[str]: ...
def get_system_encoding() -> str: ...

DEFAULT_LOCALE_ENCODING: Any
